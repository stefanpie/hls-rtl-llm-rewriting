import json
import os
import re
import shutil
import subprocess
from pathlib import Path
from pprint import pp
from string import Template
from typing import TypeVar

from dotenv import load_dotenv
from joblib import Parallel, delayed
from llm import Model
from llm_openrouter import OpenRouterChat

load_dotenv()


T_unwrap = TypeVar("T_unwrap")


def unwrap(x: T_unwrap | None) -> T_unwrap:
    if x is None:
        raise ValueError("Unwrapped a None Value")
    return x


def find_bin(bin_name: str) -> Path | None:
    match = shutil.which(bin_name)
    return Path(match) if match is not None else None


def formal_equiv_yosys(
    original_txt: str,
    rewritten_txt: str,
    work_dir: Path,
    top_module: str,
    design_dir: Path,
):
    if work_dir.exists() is True:
        shutil.rmtree(work_dir)
    work_dir.mkdir(parents=True, exist_ok=True)

    original_fp = work_dir / "original.v"
    original_fp.write_text(original_txt)
    rewritten_fp = work_dir / "rewritten.v"
    rewritten_fp.write_text(rewritten_txt)

    original_files = list(design_dir.rglob("*.v"))
    orig_files_copy_dir = work_dir / "orig_files"
    orig_files_copy_dir.mkdir(parents=True, exist_ok=True)
    for f in original_files:
        shutil.copy(f, orig_files_copy_dir / f.name)

    eqy_config_fp = work_dir / "config.eqy"

    s = "[gold]\n"
    for f in orig_files_copy_dir.rglob("*.v"):
        s += f"read_verilog -sv {f}\n"
    s += f"read_verilog -sv -overwrite {original_fp}\n"
    s += f"prep -top {top_module}\n"
    s += "setundef -undriven -zero\n"
    s += "setundef -init -zero\n"

    s += "[gate]\n"
    for f in orig_files_copy_dir.rglob("*.v"):
        s += f"read_verilog -sv {f}\n"
    s += f"read_verilog -sv -overwrite {rewritten_fp}\n"
    s += f"prep -top {top_module}\n"
    s += "setundef -undriven -zero\n"
    s += "setundef -init -zero\n"

    s += "[strategy induction]\n"
    s += "use sby\n"
    # s += "engine smtbmc z3\n"
    s += "engine abc pdr\n"

    eqy_config_fp.write_text(s)

    N_JOBS = 32

    eqy_bin = unwrap(find_bin("eqy"))
    args = [str(eqy_bin), "--jobs", str(N_JOBS), eqy_config_fp]

    p = subprocess.run(args, capture_output=True, text=True, cwd=work_dir)

    log_fp = work_dir / "log.txt"
    log_fp.write_text(p.stdout + "\n\n\n" + p.stderr)

    if p.returncode != 0:
        return False

    if not log_fp.exists():
        raise RuntimeError("Yosys EQY log file not found")
    txt_log = log_fp.read_text()
    txt_lines = [line.strip() for line in txt_log.splitlines() if line.strip()]
    txt_last_line = txt_lines[-1]

    if "PASS" not in txt_last_line:
        return False
    else:
        return True


def check_design_synth(
    verilog_txt: str, work_dir: Path, top_module: str, design_dir: Path
) -> bool:
    if work_dir.exists() is True:
        shutil.rmtree(work_dir)
    work_dir.mkdir(parents=True, exist_ok=True)
    verilog_fp = work_dir / "code.v"
    verilog_fp.write_text(verilog_txt)

    original_files = list(design_dir.rglob("*.v"))
    orig_files_copy_dir = work_dir / "orig_files"
    orig_files_copy_dir.mkdir(parents=True, exist_ok=True)
    for f in original_files:
        shutil.copy(f, orig_files_copy_dir / f.name)

    yosys_script_fp = work_dir / "script.ys"
    s = ""
    for f in orig_files_copy_dir.rglob("*.v"):
        s += f"read_verilog {f};\n"
    s += f"read_verilog -overwrite {verilog_fp};\n"
    s += f"synth -top {top_module};\n"
    s += "stat;\n"
    yosys_script_fp.write_text(s)

    log_fp = work_dir / "log.txt"

    yosys_bin = unwrap(find_bin("yosys"))
    args = [str(yosys_bin), "-s", str(yosys_script_fp), "-l", str(log_fp)]

    p = subprocess.run(args, capture_output=True, text=True, cwd=work_dir)

    p_txt_fp = work_dir / "process.txt"
    p_txt_fp.write_text(p.stdout + "\n\n\n" + p.stderr)

    passed = p.returncode == 0
    return passed


SYSTEM_PROMPT = """
You are an High Level Synthesis (HLS) and Verilog expert.
The goal is to rewrite the generated Verilog code from HLS tools to be simpler and higher-level HDL.
You will be given a Verilog code that was generated by an HLS tool (like Vitis HLS or Intel HLS).
You will rewrite the code completely, improving the layout and implementation of the module and lifting to a higher semantic level while preserving the same functionality.
It should not look like it was generated by an HLS tool anymore, but written by a human expert for someone else to read.
Ideally it should be shorter, but it can also be longer if that improves clarity and structure.
You are allowed to make major changes to the structure of HDL.
You can also add brief descriptive comments to explain the purpose of different sections of the code.
The rewritten code should be functionally equivalent to the original code and will be checked using formal equivalence checking tools.
Just treat any instances of modules not defined in the input as black boxes; you can move these instances around and rename them;
You must not change the top level module name, its interface (input/output ports), or its parameter values. The same applies to instances parameter values of black box modules.
Top level port should maintain the same names, shapes, directions, and types (wires/reg).
Don't make simple mistakes like having a signal with multiple drivers.

Only respond with the rewritten Verilog code in a single markdown code block. This should be complete and valid Verilog code, not just fragments or snippets. Do not omit any parts of the code or add todo comments.
"""

USER_PROMPT = """
INPUT VERILOG:
```verilog
${input_verilog}
```
"""

PROMPT_TEMPLATE = Template(USER_PROMPT)

_CODEBLOCK_RE = re.compile(
    r"(?s)"  # dot matches newlines
    r"(?P<fence>```+|~~~+)"  # opening fence of backticks or tildes (len>=3)
    r"(?P<info>[^\n]*)\n"  # optional info string (language), up to first newline
    r"(?P<code>.*?)"  # the code itself, non-greedy
    r"(?P=fence)"  # matching closing fence of same type/length
)


def extract_fenced_code(markdown_text: str) -> tuple[str, str | None]:
    """
    Extract the first fenced Markdown code block from `markdown_text`.

    Returns:
        (code, language)
        - code: the contents of the code fence
        - language: the language tag if present (e.g., 'python'), else None

    Raises:
        ValueError if no fenced code block is found.
    """
    m = _CODEBLOCK_RE.search(markdown_text)
    if not m:
        raise ValueError("No fenced Markdown code block found.")
    # Clean up the language/info string (could include extra attrs)
    info = (m.group("info") or "").strip()
    # Language is the first token in the info string, if any
    lang = info.split()[0] if info else None
    code = m.group("code")
    # Normalize common trailing newline quirks
    if code.endswith("\n"):
        code = code[:-1]
    return code, lang


def build_model_openrouter(model_id: str, api_key: str) -> OpenRouterChat:
    return OpenRouterChat(
        model_id=model_id,
        key=api_key,
        api_base="https://openrouter.ai/api/v1",
        headers={"HTTP-Referer": "https://llm.datasette.io/", "X-Title": "LLM"},
    )


def attempt_rewrite__oneshot(
    input_verilog: str,
    work_dir: Path,
    top_module: str,
    design_dir: Path,
    llm: Model | OpenRouterChat,
    n: int = 1,
    n_jobs: int = 1,
):
    if work_dir.exists() is True:
        shutil.rmtree(work_dir)
    work_dir.mkdir(parents=True, exist_ok=True)

    design_name = design_dir.name
    module_name = top_module
    metadata = {
        "name_design": design_name,
        "name_module": module_name,
    }
    metadata_fp = work_dir / "metadata.json"
    metadata_fp.write_text(json.dumps(metadata, indent=4))

    original_fp = work_dir / "original.v"
    original_fp.write_text(input_verilog)

    rewrite_attempts_dir = work_dir / "rewrite_attempts"
    rewrite_attempts_dir.mkdir(parents=True, exist_ok=True)

    def process_attempt(i: int):
        rewritten_attempt_dir = rewrite_attempts_dir / f"rewritten__{i}"
        rewritten_attempt_dir.mkdir(parents=True, exist_ok=True)

        prompt = PROMPT_TEMPLATE.substitute(input_verilog=input_verilog)

        llm_input_fp = rewritten_attempt_dir / "llm_prompt.txt"
        llm_input_fp.write_text(prompt)

        print(f"Attempt {i}: Sending prompt to LLM...")
        response = llm.prompt(prompt, system=SYSTEM_PROMPT)
        response_txt = response.text()
        print(f"Attempt {i}: Received response from LLM.")

        llm_output_fp = rewritten_attempt_dir / "llm_response.txt"
        llm_output_fp.write_text(response_txt)

        code, lang = extract_fenced_code(response_txt)
        rewritten_fp = rewritten_attempt_dir / "rewritten.v"
        rewritten_fp.write_text(code)

        check_passed = check_design_synth(
            verilog_txt=code,
            work_dir=rewritten_attempt_dir / "check_design",
            top_module=top_module,
            design_dir=design_dir,
        )
        check_equiv_passed = formal_equiv_yosys(
            original_txt=input_verilog,
            rewritten_txt=code,
            work_dir=rewritten_attempt_dir / "formal_equiv",
            top_module=top_module,
            design_dir=design_dir,
        )

        results = {
            "check_synth": check_passed,
            "check_equiv": check_equiv_passed,
        }

        results_fp = rewritten_attempt_dir / "results.json"
        results_fp.write_text(json.dumps(results, indent=4))

    Parallel(n_jobs=n_jobs, backend="threading")(
        delayed(process_attempt)(i) for i in range(n)
    )


def extract_non_port_vars_from_slang_ast(ast: dict) -> list[str]:
    """Return a list of nets/variables declared in the top-level InstanceBody
    that are not also ports.

    Walks the AST looking for an object with "kind" == "InstanceBody"
    (the top module body), collects members where kind is one of
    ('Port','Net','Variable') and returns nets+variables minus ports.
    """

    def find_instance_body(node: object) -> dict | None:
        if not isinstance(node, dict):
            return None
        if node.get("kind") == "InstanceBody":
            return node
        for v in node.values():
            if isinstance(v, dict):
                found = find_instance_body(v)
                if found:
                    return found
            elif isinstance(v, list):
                for item in v:
                    if isinstance(item, dict):
                        found = find_instance_body(item)
                        if found:
                            return found
        return None

    body = find_instance_body(ast)
    if body is None:
        raise ValueError("No InstanceBody found in AST")

    members = body.get("members", [])
    port_names = set()
    net_names = set()
    var_names = set()
    for m in members:
        if not isinstance(m, dict):
            continue
        kind = m.get("kind")
        name = m.get("name")
        if not name:
            continue
        if kind == "Port":
            port_names.add(name)
        elif kind == "Net":
            net_names.add(name)
        elif kind == "Variable":
            var_names.add(name)

    return sorted((net_names | var_names) - port_names)


def extract_vars_for_module(ast: dict, module_name: str) -> list[str]:
    """Find the Instance with the given module_name and return its non-port
    nets/variables.

    This is safer if the AST contains multiple modules/instances.
    """
    if not isinstance(ast, dict):
        raise TypeError("ast must be a dict")

    # Search for an Instance node with matching name
    def find_instance(node: object) -> dict | None:
        if not isinstance(node, dict):
            return None
        if node.get("kind") == "Instance" and node.get("name") == module_name:
            return node
        for v in node.values():
            if isinstance(v, dict):
                found = find_instance(v)
                if found:
                    return found
            elif isinstance(v, list):
                for item in v:
                    if isinstance(item, dict):
                        found = find_instance(item)
                        if found:
                            return found
        return None

    inst = find_instance(ast)
    if inst is None:
        # fallback: if there's only one InstanceBody in the AST, use it
        try:
            return extract_non_port_vars_from_slang_ast(ast)
        except Exception:
            raise ValueError(f"Module {module_name} not found in AST")

    # instance node should have a 'body' with 'members'
    body = inst.get("body")
    if not isinstance(body, dict) or "members" not in body:
        raise ValueError(f"Instance for module {module_name} has no body/members")

    members = body.get("members", [])
    port_names = set()
    net_names = set()
    var_names = set()
    for m in members:
        if not isinstance(m, dict):
            continue
        kind = m.get("kind")
        name = m.get("name")
        if not name:
            continue
        if kind == "Port":
            port_names.add(name)
        elif kind == "Net":
            net_names.add(name)
        elif kind == "Variable":
            var_names.add(name)

    return sorted((net_names | var_names) - port_names)


SYSTEM_PROMPT_VAR = """
You are an High Level Synthesis (HLS) and Verilog expert.
The goal is to rename auto-generated variables in the auto-generated Verilog code from HLS tools to be simpler, higher-level, human-readable HDL.
You will be given a Verilog code that was generated by an HLS tool (like Vitis HLS) as well as a list of variable names in the design that are available to rename.
You will create a mapping of old variable names to new variable names you suggest that improve clarity, structure, function, debuggability, and readability while preserving the same functionality.
You dont have to stricly rename all variables, but try to rename as many as possible to improve the HDL as much as possible.
Avoid "tmp" or "temp" in the new variable names. These do not improve clarity.

Only respond with a JSON object mapping old variable names to new variable names. The type is `dict[str, str]`.
The output should be a markdown code block with language `json`, containing only the JSON object with only the mapping.
Example output:
```json
{
    "old_var1": "new_var1",
    "old_var2": "new_var2",
}
```
""".strip()

USER_PROMPT_VAR = """
INPUT VERILOG
```verilog
${input_verilog}
```
VARIABLES THAT CAN BE RENAMED:
```txt
${variable_list}
```
""".strip()


def attempt_rewrite__variables(
    input_verilog: str,
    work_dir: Path,
    top_module: str,
    design_dir: Path,
    llm: Model | OpenRouterChat,
    n: int = 1,
    n_jobs: int = 1,
):
    if work_dir.exists() is True:
        shutil.rmtree(work_dir)
    work_dir.mkdir(parents=True, exist_ok=True)

    design_name = design_dir.name
    module_name = top_module
    metadata = {
        "name_design": design_name,
        "name_module": module_name,
    }
    metadata_fp = work_dir / "metadata.json"
    metadata_fp.write_text(json.dumps(metadata, indent=4))

    original_fp = work_dir / "original.v"
    original_fp.write_text(input_verilog)

    yosys_script = f"""
    plugin -i slang
    read_slang --dump-ast --ignore-timing --ast-compilation-only --ignore-unknown-modules {str(original_fp)}
    """
    yosys_script_fp = work_dir / "get_ast.ys"
    yosys_script_fp.write_text(yosys_script)

    cmd = ["yosys", "-s", str(yosys_script_fp)]
    p = subprocess.run(cmd, capture_output=True, text=True, cwd=work_dir)
    if p.returncode != 0:
        print("Error running yosys to get AST:")
        print(p.stdout)
        print(p.stderr)
        raise RuntimeError("Yosys failed to get AST")

    stdout = p.stdout
    ast_json_txt = stdout[stdout.index("{") : stdout.rindex("}") + 1]
    ast = json.loads(ast_json_txt)
    ast_fp = work_dir / "ast.json"
    ast_fp.write_text(json.dumps(ast, indent=4))

    vars_for_module = extract_vars_for_module(ast, top_module)
    vars_fp = work_dir / "variables.json"
    vars_fp.write_text(json.dumps(vars_for_module, indent=2))

    rewrite_attempts_dir = work_dir / "rewrite_attempts"
    rewrite_attempts_dir.mkdir(parents=True, exist_ok=True)

    def process_attempt(i: int):
        rewritten_attempt_dir = rewrite_attempts_dir / f"rewritten__{i}"
        rewritten_attempt_dir.mkdir(parents=True, exist_ok=True)

        variable_list_txt = "\n".join(vars_for_module)
        user_prompt = USER_PROMPT_VAR.replace(
            "${input_verilog}", input_verilog
        ).replace("${variable_list}", variable_list_txt)

        prompt_vis = ""
        prompt_vis += "SYSTEM PROMPT:\n\n"
        prompt_vis += SYSTEM_PROMPT_VAR + "\n\n\n"
        prompt_vis += "USER PROMPT:\n\n"
        prompt_vis += user_prompt

        llm_prompt_fp = rewritten_attempt_dir / "llm_prompt.txt"
        llm_prompt_fp.write_text(prompt_vis)

        print(f"Attempt {i}: Sending prompt to LLM")
        response = llm.prompt(user_prompt, system=SYSTEM_PROMPT_VAR)
        response_txt = response.text()

        llm_response_fp = rewritten_attempt_dir / "llm_response.txt"
        llm_response_fp.write_text(response_txt)

        code, lang = extract_fenced_code(response_txt)
        try:
            var_mapping = json.loads(code)
        except Exception as e:
            print(f"Failed to parse JSON from LLM response in attempt {i}: {e}")
            return
        (rewritten_attempt_dir / "var_mapping.json").write_text(
            json.dumps(var_mapping, indent=4)
        )

        old_vars = list(var_mapping.keys())
        new_vars = list(var_mapping.values())

        if len(new_vars) != len(set(new_vars)):
            print(f"New variable names are not unique in attempt {i}")
            non_unique = set(v for v in new_vars if new_vars.count(v) > 1)
            print(f"Non-unique new variable names: {non_unique}")

        for ov in old_vars:
            if ov not in vars_for_module:
                print(
                    f"Old variable {ov} not found in original variable list in attempt {i}"
                )

        rewritten_verilog = input_verilog
        var_map_items = sorted(var_mapping.items(), key=lambda x: -len(x[0]))
        for old_var, new_var in var_map_items:
            rewritten_verilog = re.sub(
                rf"(?<![.\\])\b{re.escape(old_var)}\b", new_var, rewritten_verilog
            )
        rewritten_fp = rewritten_attempt_dir / "rewritten.v"
        rewritten_fp.write_text(rewritten_verilog)

        check_passed = check_design_synth(
            verilog_txt=rewritten_verilog,
            work_dir=rewritten_attempt_dir / "check_design",
            top_module=top_module,
            design_dir=design_dir,
        )
        check_equiv_passed = formal_equiv_yosys(
            original_txt=input_verilog,
            rewritten_txt=rewritten_verilog,
            work_dir=rewritten_attempt_dir / "formal_equiv",
            top_module=top_module,
            design_dir=design_dir,
        )

        results = {
            "check_synth": check_passed,
            "check_equiv": check_equiv_passed,
        }
        results_fp = rewritten_attempt_dir / "results.json"
        results_fp.write_text(json.dumps(results, indent=4))

    Parallel(n_jobs=n_jobs, backend="threading")(
        delayed(process_attempt)(i) for i in range(n)
    )
