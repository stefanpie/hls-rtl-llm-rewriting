import os
import re
import shutil
import subprocess
from pathlib import Path
from string import Template

from dotenv import load_dotenv
from llm_openrouter import OpenRouterChat

load_dotenv()

DIR_CURRENT = Path(__file__).parent


def unwrap[T](x: T | None) -> T:
    if x is None:
        raise ValueError("Unwrapped a None Value")
    return x


def find_bin(bin_name: str) -> Path | None:
    match = shutil.which(bin_name)
    return Path(match) if match is not None else None


def formal_equiv_yosys(
    original_txt: str,
    rewritten_txt: str,
    work_dir: Path,
    top_module: str,
    design_dir: Path,
):
    if work_dir.exists() is True:
        shutil.rmtree(work_dir)
    work_dir.mkdir(parents=True, exist_ok=True)

    original_fp = work_dir / "original.v"
    original_fp.write_text(original_txt)
    rewritten_fp = work_dir / "rewritten.v"
    rewritten_fp.write_text(rewritten_txt)

    original_files = list(design_dir.rglob("*.v"))
    orig_files_copy_dir = work_dir / "orig_files"
    orig_files_copy_dir.mkdir(parents=True, exist_ok=True)
    for f in original_files:
        shutil.copy(f, orig_files_copy_dir / f.name)

    eqy_config_fp = work_dir / "config.eqy"

    s = "[gold]\n"
    for f in orig_files_copy_dir.rglob("*.v"):
        s += f"read_verilog -sv {f}\n"
    s += f"read_verilog -sv -overwrite {original_fp}\n"
    s += f"prep -top {top_module}\n"
    s += "setundef -undriven -zero\n"
    s += "setundef -init -zero\n"

    s += "[gate]\n"
    for f in orig_files_copy_dir.rglob("*.v"):
        s += f"read_verilog -sv {f}\n"
    s += f"read_verilog -sv -overwrite {rewritten_fp}\n"
    s += f"prep -top {top_module}\n"
    s += "setundef -undriven -zero\n"
    s += "setundef -init -zero\n"

    s += "[strategy induction]\n"
    s += "use sby\n"
    s += "engine smtbmc z3\n"

    eqy_config_fp.write_text(s)

    eqy_bin = unwrap(find_bin("eqy"))
    args = [str(eqy_bin), eqy_config_fp]

    p = subprocess.run(args, capture_output=True, text=True, cwd=work_dir)

    log_fp = work_dir / "log.txt"
    log_fp.write_text(p.stdout + "\n\n\n" + p.stderr)


def check_design(
    verilog_txt: str, work_dir: Path, top_module: str, design_dir: Path
) -> bool:
    if work_dir.exists() is True:
        shutil.rmtree(work_dir)
    work_dir.mkdir(parents=True, exist_ok=True)
    verilog_fp = work_dir / "code.v"
    verilog_fp.write_text(verilog_txt)

    original_files = list(design_dir.rglob("*.v"))
    orig_files_copy_dir = work_dir / "orig_files"
    orig_files_copy_dir.mkdir(parents=True, exist_ok=True)
    for f in original_files:
        shutil.copy(f, orig_files_copy_dir / f.name)

    yosys_script_fp = work_dir / "script.ys"
    s = ""
    for f in orig_files_copy_dir.rglob("*.v"):
        s += f"read_verilog {f};\n"
    s += f"read_verilog -overwrite {verilog_fp};\n"
    s += f"synth -top {top_module};\n"
    s += "stat;\n"
    yosys_script_fp.write_text(s)

    log_fp = work_dir / "log.txt"

    yosys_bin = unwrap(find_bin("yosys"))
    args = [str(yosys_bin), "-s", str(yosys_script_fp), "-l", str(log_fp)]

    p = subprocess.run(args, capture_output=True, text=True, cwd=work_dir)

    p_txt_fp = work_dir / "process.txt"
    p_txt_fp.write_text(p.stdout + "\n\n\n" + p.stderr)

    return p.returncode == 0


SYSTEM_PROMPT = """
You are an High Level Synthesis (HLS) and Verilog expert.
The goal is to rewrite the generated Verilog code from HLS tools to be simpler and higher-level HDL.
You will be given a Verilog code that was generated by an HLS tool (like Vitis HLS or Intel HLS).
You will rewrite the code completely, improving the layout and implementation of the module and lifting to a higher semantic level while preserving the same functionality.
It should not look like it was generated by an HLS tool anymore, but written by a human expert for someone else to read.
Ideally it should be shorter, but it can also be longer if that improves clarity and structure.
You are allowed to make major changes to the structure of HDL.
You can also add brief descriptive comments to explain the purpose of different sections of the code.
The rewritten code should be functionally equivalent to the original code and will be checked using formal equivalence checking tools.
Just treat any instances of modules not defined in the input as black boxes; you can move these instances around and rename them;
You must not change the top level module name, its interface (input/output ports), or its parameter values. The same applies to instances parameter values of black box modules.
Top level port should maintain the same names, shapes, directions, and types (wires/reg).
Don't make simple mistakes like having a signal with multiple drivers.

Only respond with the rewritten Verilog code in a single markdown code block. This should be complete and valid Verilog code, not just fragments or snippets. Do not omit any parts of the code or add todo comments.
"""

USER_PROMPT = """
INPUT VERILOG:
```verilog
${input_verilog}
```
"""

PROMPT_TEMPLATE = Template(USER_PROMPT)

_CODEBLOCK_RE = re.compile(
    r"(?s)"  # dot matches newlines
    r"(?P<fence>```+|~~~+)"  # opening fence of backticks or tildes (len>=3)
    r"(?P<info>[^\n]*)\n"  # optional info string (language), up to first newline
    r"(?P<code>.*?)"  # the code itself, non-greedy
    r"(?P=fence)"  # matching closing fence of same type/length
)


def extract_fenced_code(markdown_text: str) -> tuple[str, str | None]:
    """
    Extract the first fenced Markdown code block from `markdown_text`.

    Returns:
        (code, language)
        - code: the contents of the code fence
        - language: the language tag if present (e.g., 'python'), else None

    Raises:
        ValueError if no fenced code block is found.
    """
    m = _CODEBLOCK_RE.search(markdown_text)
    if not m:
        raise ValueError("No fenced Markdown code block found.")
    # Clean up the language/info string (could include extra attrs)
    info = (m.group("info") or "").strip()
    # Language is the first token in the info string, if any
    lang = info.split()[0] if info else None
    code = m.group("code")
    # Normalize common trailing newline quirks
    if code.endswith("\n"):
        code = code[:-1]
    return code, lang


MODEL_ID = "openai/gpt-oss-120b"
MODEL_PROVIDER = {"only": ["chutes"]}

# MODEL_ID = "google/gemini-2.5-flash"
# MODEL_PROVIDER = {"only": ["google-vertex"]}

llm: OpenRouterChat = OpenRouterChat(
    model_id=MODEL_ID,
    key=os.getenv("OPENROUTER_API_KEY"),
    api_base="https://openrouter.ai/api/v1",
    headers={"HTTP-Referer": "https://llm.datasette.io/", "X-Title": "LLM"},
)


def attempt_rewrite__oneshot(
    input_verilog: str,
    work_dir: Path,
    top_module: str,
    design_dir: Path,
):
    if work_dir.exists() is True:
        shutil.rmtree(work_dir)
    work_dir.mkdir(parents=True, exist_ok=True)

    original_fp = work_dir / "original.v"
    original_fp.write_text(input_verilog)

    rewrite_attempts_dir = work_dir / "rewrite_attempts"
    rewrite_attempts_dir.mkdir(parents=True, exist_ok=True)

    N = 5

    for i in range(N):
        rewritten_attempt_dir = rewrite_attempts_dir / f"rewritten__{i}"
        rewritten_attempt_dir.mkdir(parents=True, exist_ok=True)

        prompt = PROMPT_TEMPLATE.substitute(input_verilog=input_verilog)

        print(f"Attempt {i}: Sending prompt to LLM...")
        response = llm.prompt(prompt, system=SYSTEM_PROMPT, provider=MODEL_PROVIDER)
        response_txt = response.text()
        print(f"Attempt {i}: Received response from LLM.")

        code, lang = extract_fenced_code(response_txt)
        rewritten_fp = rewritten_attempt_dir / "rewritten.v"
        rewritten_fp.write_text(code)

        check_passed = check_design(
            verilog_txt=code,
            work_dir=rewritten_attempt_dir / "check_design",
            top_module=top_module,
            design_dir=design_dir,
        )
        check_equiv_passed = formal_equiv_yosys(
            original_txt=input_verilog,
            rewritten_txt=code,
            work_dir=rewritten_attempt_dir / "formal_equiv",
            top_module=top_module,
            design_dir=design_dir,
        )


def attempt_rewrite__variables(
    input_verilog: str,
    work_dir: Path,
    top_module: str,
    design_dir: Path,
):
    # TODO: Implement a variable-only based LLM rewriting approach
    # Input prompt is the original verilog with the verilog module + variables in the module we want to rename
    # LLM output should be a mapping of old variable names we listed to new variable names
    # Other Notes:
    # - Maybe use structured output for LLM
    # - Maybe use multiple rounds of variable renaming
    # - Maybe use parser / AST to do the renaming based on the LLM generated mapping
    #   or use some regex somehow carefully to rename variables a hacky way


if __name__ == "__main__":
    # kernel_2mm_kernel_2mm_Pipeline_VITIS_LOOP_27_1_VITIS_LOOP_28_2

    design_dir = DIR_CURRENT / "test_design"
    test_file_name = "kernel_2mm_kernel_2mm_Pipeline_VITIS_LOOP_27_1_VITIS_LOOP_28_2.v"
    test_file_fp = design_dir / test_file_name
    top_module = "kernel_2mm_kernel_2mm_Pipeline_VITIS_LOOP_27_1_VITIS_LOOP_28_2"

    input_verilog = test_file_fp.read_text()
    attempt_rewrite__oneshot(
        input_verilog=input_verilog,
        work_dir=DIR_CURRENT / "work" / top_module,
        top_module=top_module,
        design_dir=design_dir,
    )
